{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tricore GNU toolchain","text":"<p>Free and open source cross-compiler toolchain for AURIX\u2122 TriCore\u2122 microcontrollers. It supports TriCore\u2122 architecture from 1.3 up to 1.8 and includes the following software:</p> <ul> <li>GCC 13.3</li> <li>Binutils 2.40</li> <li>libc based on Cygwin Newlib</li> <li>QEMU 9.2.0</li> <li>GDB 14.0 with Tricore support</li> </ul> <p>This repository is a downstream of EEESlab/tricore-gcc-toolchain-11.3.0 that aims to be a playground for new features and improvements with a faster developement process and automated release management. All the meaningful changes will be contributed back to upstream repository</p>"},{"location":"#download","title":"Download","text":"<p>Grab the latest pre-compiled toolchain from GitHub releases.</p> <p>To build manually from sources, please refer to the build page.</p>"},{"location":"#code-samples","title":"Code samples","text":"<ul> <li>AURIX_code_examples: collection of code samples from Infineon meant to be used with AURIX\u2122 Development Studio</li> <li>aurix-cmake-code-sample: Project based on Blinky_LED_1_KIT_TC334_LK from Infineon repository updated with CMake supports and modern tools (clang-format, clang-tidy)</li> </ul>"},{"location":"building/","title":"Build instructions","text":""},{"location":"building/#gcc-toolchain","title":"GCC Toolchain","text":""},{"location":"building/#native-build","title":"Native build","text":"<p>This chapter refers to building the Tricore cross-compiler directly from the host architecture.</p> <p>Instructions showed here are tested on Ubuntu 22.04 (see Github Actions script), but should ideally work on other Linux distributions and also MSYS2 Windows environment.</p> <p>Clone the repository:</p> <pre><code>git clone --recursive https://github.com/NoMore201/tricore-gcc-toolchain\n</code></pre> <p>Install build dependencies:</p> <pre><code>sudo ./scripts/install-apt-dependencies\n</code></pre> <p>Create a temporary build directory and call the <code>configure</code> script</p> <pre><code>mkdir build &amp;&amp; cd build\n../configure --prefix=/path/to/prefix\nmake -j$(nproc) stamps/build-gcc-stage2\n</code></pre> <p>This will build and install everything into <code>/path/to/prefix</code>.</p> <p>It is also possible to compile single components of the toolchain. For further information on the available options, refer to <code>configure</code> script help page and the Makefile.</p>"},{"location":"building/#mingw-canadian-cross-build","title":"MinGW canadian cross build","text":"<p>Sometimes it may be useful to build a cross-compiler from architecture B to architecture C, by performing the build on a third architecture A. The reason is that setting up architecture B for cross-compilation may be not as easy as on architecture A. This is called a  canadian cross.</p> <p>In this case, the idea is to build Win32 tricore-elf-gcc (cross-compiler from Win32 to <code>tricore-elf</code>) directly on Linux due to easier setup and the  reproducibility of the environment.</p> <p>You can see an example of a canadian cross build in the Github Actions script. First clone the toolchain repository:</p> <pre><code>git clone --recursive https://github.com/NoMore201/tricore-gcc-toolchain\n</code></pre> <p>Install build dependencies, including MinGW cross-compiler:</p> <pre><code>sudo ./scripts/install-apt-dependencies\n</code></pre> <p>First we need to build the linux -&gt; tricore cross-compiler. Refer to the Native build chapter on how to do so.</p> <p>When linux -&gt; tricore cross-compiler is ready, we need to install the newlib also into the final Win32 prefix. To do so, switch to the linux build directory and call make by swapping the prefix variable:</p> <pre><code>cd build-linux/build-newlib\nmake install prefix=/path/to/win32-prefix\n</code></pre> <p>Now modify <code>PATH</code> environment variable with the PATH to linux cross-compiler:</p> <pre><code>export PATH=\"/path/to/linux-prefix:$PATH\"\n</code></pre> <p>Finally we configure and build the missing components with the following commands</p> <pre><code>mkdir build-win32 &amp;&amp; cd build-win32\n../configure --prefix /path/to/win32-prefix --with-host=x86_64-w64-mingw32\nmake -j$(nproc) stamps/build-binutils-tc\nexport PATH=\"/opt/gcc/linux/bin:$PATH\"\nmake -j$(nproc) stamps/build-gcc-stage2-only\n</code></pre>"},{"location":"building/#qemu","title":"QEMU","text":""},{"location":"building/#native-build_1","title":"Native build","text":"<p>QEMU native build is pretty straightforward. First install dependencies, either manually or by running:</p> <pre><code>sudo ./scripts/install-apt-dependencies\n</code></pre> <p>Note: this will install meson through pip system-wide, since QEMU needs a recent meson version that ubuntu repositories do not have. If you don't want to install system-wide packages through pip, proceed with virtualenv</p> <p>Once dependencies are installed, proceed with build command:</p> <pre><code>mkdir build-linux &amp;&amp; cd build-linux\n../configure --prefix /path/to/linux-prefix\nmake -j$(nproc) stamps/build-qemu\n</code></pre>"},{"location":"building/#cross-compile-with-mingw","title":"Cross-compile with MinGW","text":"<p>To cross-compile QEMU for Windows, follow the native build instructions, with the only difference that you need to specify host target to the configure command:</p> <pre><code>mkdir build-win32 &amp;&amp; cd build-win32\n../configure --prefix /path/to/win32-prefix --with-host=x86_64-w64-mingw32\nmake -j$(nproc) stamps/build-qemu\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#1131-20250101","title":"11.3.1-20250101","text":"<ul> <li>Enable GDB build in tricore-binutils-gdb</li> <li>Merge GDB patches from go2sh/tricore-binutils-gdb</li> <li>Add material mkdocs docs with github actions trigger</li> <li>Fix LD crash in tricore-binutils-gdb</li> <li>Fix static build of GDB requiring external dependencies</li> </ul>"},{"location":"changelog/#1131-20241211","title":"11.3.1-20241211","text":"<ul> <li>toolchain: Added QEMU 9.2.0 static executable to the toolchain, compiled with   tricore support enabled</li> <li>script: Switch build script to a GNU autoconf based solution, insipired by   RiscV toolchain repository</li> <li>release: Switched from commit SHA based release number to date release number.   From now on, all releases will be tagged as <code>11.3.1-&lt;date&gt;</code> to better recognize   different versions</li> </ul>"},{"location":"changelog/#1131-5e4ca74","title":"11.3.1-5e4ca74","text":"<ul> <li>binutils: Rename padding data, check for null pointer when dereferencing</li> <li>script: Use -gdwarf-3 option for win32 build</li> </ul>"},{"location":"changelog/#1131-258811c","title":"11.3.1-258811c","text":"<ul> <li>binutils: Fix issue in extended map table showing garbage   data for memory sections</li> <li>gcc: Fix build for macOS</li> <li>gcc: Add support for Tricore TC33x family MCUs</li> </ul>"},{"location":"changelog/#1131-6eca707","title":"11.3.1-6eca707","text":"<ul> <li>binutils: Fix issue in LD linker that caused crashes with some linker scripts</li> </ul>"},{"location":"qemu-debug/","title":"Debug you software using QEMU + GDB","text":"<p>This toolchain provides <code>qemu-system-tricore</code> and <code>tricore-elf-gdb</code> for running and debugging your code in a simulated environment.</p> <p>QEMU support for Tricore architecture is incomplete. It provides only basic CPU instruction decode (no interrupts or multi-core) and no peripheral is available. Only core architecture from tc1.3 up to tc1.6.2 is supported</p>"},{"location":"qemu-debug/#setup","title":"Setup","text":"<p>The code below uses ELF executable built from aurix-cmake-code-sample in debug mode (no optimizations and debug symbols enabled). It should work with any Tricore ELF file built with DWARF v3 debug symbols.</p> <p>First step is to run QEMU providing the ELF executable, enabling gdb stub for remote debugging and enable startup freeze option to be able to connect before running the emulation.</p> <pre><code>$ qemu-system-tricore -machine KIT_AURIX_TC277_TRB -kernel ./out/debug/src/aurix_sample_tc33x.elf -s -S\n</code></pre> <p>Next we run tricore-elf-gdb, set the architecture version to 1.6.2 and connect to QEMU gdb stub:</p> <pre><code>$ tricore-elf-gdb ./out/debug/src/aurix_sample_tc33x.elf\n\nGNU gdb (GDB) 14.0.50.20230607-git\nCopyright (C) 2023 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\nType \"show copying\" and \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-pc-linux-gnu --target=tricore-elf\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n&lt;https://www.gnu.org/software/gdb/bugs/&gt;.\nFind the GDB manual and other documentation resources online at:\n    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.\n\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from /mnt/c/git/aurix-cmake-code-sample/out/debug/src/aurix_sample_tc33x.elf...\n\n(gdb) set architecture TriCore:V1_6_2\nThe target architecture is set to \"TriCore:V1_6_2\".\n\n(gdb) target remote localhost:1234\nRemote debugging using localhost:1234\nIfx_Ssw_jumpToFunction (fun=&lt;optimized out&gt;)\n    at /home/nomore/Workspace/aurix-cmake-code-sample/third_party/infineon/Libraries/Infra/Ssw/TC33A/Tricore/Ifx_Ssw_CompilersGnuc.h:183\n183         __asm__ volatile (\"ji %0\" ::\"a\" (fun));\n</code></pre> <p>Now you can start debugging your code through QEMU.</p> <p></p>"},{"location":"qemu-debug/#debugging-through-vscode","title":"Debugging through VSCode","text":"<p>When using VScode with C/C++ extension is it possible to directly run GDB from the code editor and debug throught the GUI.</p> <p>All you need to do is provide a custom <code>launch.json</code> configuration, making sure to adjust <code>program</code> and <code>miDebuggerPath</code> according to your environment.</p> <p>When using VS Code with the C/C++ extension, you can directly run GDB from the code editor and debug through the GUI. Simply provide a custom <code>launch.json</code> configuration, ensuring you adjust <code>program</code> and <code>miDebuggerPath</code> settings to match your environment.</p> <pre><code>{\n    // make sure QEMU is running your executable with gdbstub enabled before\n    // launching this\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"tricore-qemu-debug\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/out/debug/src/aurix_sample_tc33x.elf\",\n            \"args\": [],\n            \"stopAtEntry\": true,\n            \"cwd\": \"${fileDirname}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"gdb\",\n            \"miDebuggerPath\": \"/opt/tricore/bin/tricore-elf-gdb\",\n            \"miDebuggerServerAddress\": \"localhost:1234\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                },\n                {\n                    \"description\": \"Set Disassembly Flavor to Intel\",\n                    \"text\": \"-gdb-set architecture TriCore:V1_6_2\",\n                    \"ignoreFailures\": false\n                }\n            ]\n        }\n\n    ]\n}\n</code></pre> <p></p>"}]}